第6条：消除过期的对象引用

过期引用是指永远也不会再被解除的引用（程序里不再引用，又不会被当作垃圾回收的对象）。

修复方法：一旦对象引用已经过期，只需清空这些引用即可。这样以后这个对象又被错误的引用，程序就会立即nullpointerexception异常，而不是悄悄的错误运行下去。

清空对象引用应该是一种例外，而不是一种规范行为。没必要对于每个用不到的对象都进行清空。消除过期引用最好的方法是让包含该引用的变量结束其声明周期。

一般而言，只要类是自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放调，则该元素中包含的任何对象引用都应该被清空。

内存泄漏的另一个常见来源是缓存。解决方案1使用WeakHashMap代表缓存；解决方案2由一个后台调度线程或者在给缓存添加新条目的时候顺便清理

内存泄漏的第三个场景来源是监听器和其他回调。确保回调立即被当作垃圾回收的最近方法是只保存它们的弱引用。

第6条：避免使用终结方法

终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。它不能保证会被及时地执行，从一个对象变得不可到达开始，到它的终结方法被执行，所花费的这段时间是任意长的。

java语言规范不仅不保证终结方法会被即时地执行，而且根本就不保证他们会被执行。

System.gc和System.runFinalization这两个方法增加了终结方法被执行的机会，但不保证终结方法一定会被执行。System.runFinalizersOnExit和Runtime.runFinalizersOnExit声称保证终结方法被执行，但已经被遗弃了。

未被捕获的异常如果发生在终结方法之中，不会使线程终止，异常栈轨迹也不会打印，甚至连警告都不会打印出来。并且该对象的终结过程也会被终止，导致对象处于破坏状态，如果其它线程企图使用这个破坏的对象则可能发生任何不确定的行为。

使用终结方法有一个非常严重的性能损失。用终结方法创建和销毁对象比简单对象慢了大约430倍。

如果类的对象中封装的资源（例如文件或者线程）确实需要终止，只需提供一个显式的终止方法，并要求客户端在每个实例不再有用的时候调用这个方法。值得提及的细节是该实例必须在私有域中记录下自己是否已被终止，如果该对象方法在终止之后被调用，则这些方法必须检查这个域，并抛出IllegalStateException异常。

显式的终止方法调用通常与try-finally结构结合起来使用，以确保及时终止。

终结方法有两种合法用途，第一种用途是当对象的所有者忘记调用显示终止方法时，终结方法可以充当“安全网”。第二种用途与对象的本地对等体（native peer）有关，本地对等体是一个本地对象（native object），普通对象通过本地方法（native method）委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的java对等体被回收的时候它不会被回收。本地对等体不拥有关键资源时，终结方法正是执行这项任务最合适的工具。如果拥有必须被及时终止的资源，那么该类应该具有一个显示的终止方法。

终结方法链并不会被自动执行。类（不是object）有终结方法，子类覆盖了终结方法，子类的终结方法就必须手工调用超类的终结方法。如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法（或者有意不调用），那么超类的终结方法将永远不会被调用。要防范这种问题可以为每个要求终结的类中增加一个匿名类，它的唯一用途就是终结它的外围实例，终结方法放在这个匿名类中，而不是外围实例，里面执行外围实例期望的终结行为，该匿名类的单个实例被称为终结方法守卫者，外围实例在它的私有域中保存守卫者的唯一引用，因此他们可以同时启动终结过程。对于每一个带有终结方法的非final共有类都应该考虑使用这种方法。

除非是作为安全网，或是为了终止非关键的本地资源，否则请不要使用终结方法。如果使用了终结方法，要记住调用super.finalize。

第3章

设计object主要是为了扩展，它的所有非final方法（equals、hashcode、tostring、clone、finalize）都设计成是要被覆盖的，都有明确的通用约定，覆盖他们时要遵守这些约定，否则其它依赖这些约定的类（如Hashmap和hashset）就无法结合该类一起正常运作。

第8条：覆盖equals时请遵守通用约定

不需要覆盖equals方法的条件：

类的每个实例本质上都是唯一的

不关心类是否提供了“逻辑相等”的测试功能

超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的

类是私有的或是包级私有的，并且您可以确定它的equals方法永远不会被调用

需要覆盖equals方法属于“值类”的情形，具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖equals以实现期望的行为。值类仅仅是一个表示值的类，如Integer或者Date。值类的equals方法用来比较逻辑上是否相等，而不是比较是否指向同一个对象。这样做使得值类的实例可以用作映射表（map）的键（key），或者集合（set）的元素，他们会表现出预期的行为。

”每个值至多只存在一个对象“的值类不需要覆盖equals方法。枚举类型就属于这种类。这样的类逻辑相同与对象等同是一回事，因此object的equals方法等同于逻辑意义上的equals方法。

覆盖equals方法时的通用约定：

equals方法实现了等价关系：

自反性。对于任何非null的引用值x，x.equals(x)必须返回true

对称性。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。

传递性。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。

一致性。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信项没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。

对于任何非null的引用值x，x.equals(null)必须返回false。

一旦违反了equals约定，当其它对象面对你的对象时，你完全不知道这些对象的行为会怎么样。

无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定，除非愿意放弃面向对象的抽象所带来的优势。一种不错的权宜之计是使用复合。可以在抽象类的子类中增加新的值组件，而不会违反equals约定。

实现高质量equals方法的诀窍：

1.使用==操作符检查“参数是否为这个对象的引用”。

2.使用instanceof操作符检查“参数是否为正确的类型”。

3.把参数转换成正确的类型。

4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。

5.当你编写完成了equals方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？（自反性和非空性通常会自动满足）

告诫：

覆盖equals时总要覆盖hashCode（见第9条）。

不要企图让equals方法过于智能。

不要将equals声明中的Object对象替换为其它的类型。